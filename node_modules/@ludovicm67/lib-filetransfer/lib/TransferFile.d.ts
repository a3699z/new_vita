import Blob from "cross-blob";
import { AskFilePartCallback, TransferFileMetadata } from "./TransferFilePool.js";
export type TransferFileInfos = {
    id: string;
    name: string;
    size: number;
    bufferLength: number;
    complete: boolean;
    downloading: boolean;
    errored: boolean;
    message: string | undefined;
};
export type TransferFileBlob = {
    name: string;
    type: string;
    size: number;
    data: Blob;
};
export declare class TransferFile {
    private id;
    private name;
    private type;
    private size;
    private parts;
    private data;
    private buffer;
    private bufferLength;
    private complete;
    private errored;
    private downloading;
    private message;
    private timeout;
    private retries;
    /**
     * Generate a new TransferFile instance.
     *
     * @param id Id of the file.
     * @param name Name of the file.
     * @param type Type of the file.
     * @param size Size of the file.
     * @param bufferLength Length of the internal buffer.
     * @param timeout Timeout for a single check in seconds.
     * @param retries Number of retries before considering it as a failure.
     */
    constructor(id: string, name: string, type: string, size: number, bufferLength: number, timeout?: number, retries?: number);
    /**
     * Set the file as being downloaded.
     *
     * @param isDownloading True if the file is being downloaded.
     */
    setDownloading(isDownloading?: boolean): void;
    /**
     * Check if the file is downloading.
     *
     * @returns true if the file is downloading.
     */
    isDownloading(): boolean;
    /**
     * Set the file as being complete.
     *
     * @param isComplete True if the download is complete.
     */
    setComplete(isComplete?: boolean): void;
    /**
     * Check if the file is complete.
     *
     * @returns true if the file is complete.
     */
    isComplete(): boolean;
    /**
     * Set an error message.
     *
     * @param message A relevant error message.
     * @param isErrored True in case of an error.
     */
    setError(message: string | undefined, isErrored?: boolean): void;
    /**
     * Get informations about the TransferFile.
     *
     * @returns Informations about the TransferFile.
     */
    getInfos(): TransferFileInfos;
    /**
     * Get the Blob of the complete file.
     *
     * @returns The Blob of the file.
     */
    getBlob(): Blob;
    /**
     * Download the file.
     *
     * @param maxBufferSize Maximum length for the data to ask at one time.
     * @param askFilePartCallback Function that will be called to ask for some parts of the file.
     * @param parallelCalls Number of parallel calls to perform (default value: `1`).
     * @param timeout Timeout for a single check in seconds.
     * @param retries Number of retries before considering it as a failure.
     * @returns
     */
    download(maxBufferSize: number, askFilePartCallback: AskFilePartCallback, parallelCalls?: number, timeout?: number, retries?: number): Promise<void>;
    /**
     * Get the file metadata.
     *
     * @returns File metadata.
     */
    getMetadata(): TransferFileMetadata;
    /**
     * Get informations representing the file.
     *
     * @returns All informations representing the file.
     */
    getFile(): TransferFileBlob;
    /**
     * Set a Blob as being the content of this file.
     */
    setBlob(blob: Blob): Promise<void>;
    /**
     * Read `limit` bytes at maximum from `offset` from the file.
     *
     * @param offset Offset from the start.
     * @param limit Maximum number of bytes to return.
     * @returns ArrayBuffer with the requested file part.
     */
    readFilePart(offset: number, limit: number): ArrayBuffer;
    /**
     * Receive a part of the file.
     *
     * @param offset Offset from the start.
     * @param limit The requested limit.
     * @param data ArrayBuffer containing the requested data.
     */
    receiveFilePart(offset: number, limit: number, data: ArrayBuffer): void;
    /**
     * Check the presence of a specific part of the file.
     *
     * @param offset Offset from the start.
     * @param limit The requested limit.
     * @returns true if the part exists or if the file is complete.
     */
    hasPart(offset: number, limit: number): ArrayBuffer;
    /**
     * Wait and check for presence of a specific part of the file.
     *
     * @param offset Offset from the start.
     * @param limit The requested limit.
     * @param timeout Timeout in seconds (default: `1`)
     * @returns true of the part was received.
     */
    waitFilePart(offset: number, limit: number, timeout?: number): Promise<boolean>;
    /**
     * Wait for a specific part of a file, with some retries.
     *
     * @param askFilePartCallback Function to ask a file part to the sender.
     * @param offset Offset from the start.
     * @param limit Maximum number of bytes that we can read.
     * @param timeout Timeout for a single check in seconds.
     * @param retries Number of retries before considering it as a failure.
     */
    waitFilePartWithRetry(askFilePartCallback: AskFilePartCallback, offset: number, limit: number, timeout?: number, retries?: number): Promise<void>;
    /**
     * Clear the content of the file.
     * The user will need to download it again.
     */
    clear(): void;
}
